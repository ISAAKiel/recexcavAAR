---
title: "Explanation"
author: "Moritz Mennenga"
date: "15. August 2017"
output: html_document
---

  A small explanation of how it works:

##Aim
The aim is to rotate the profile fotogrammetric control points (fgc) so that it is possible to rectify profile images of archaeological excavations.

The georeferencer of QGIS provides the projective transformation for georeferencing, that is used to rectify the profiles.

##Execution
Loading the data.

The data basis can be a spatial data frame with 3D points or a table with x,y and z coordinates. The process is only for cartesian coordinates.

These are the input options

- *(Spatial)dataframe*: Input data

- *view_col*: The column with the information of the direction of view (the position of the observer towards the profile -> "N, E, S, W"). This information influences the direction of rotation.

- *profile_col*: The column with the information of the profilenames.

- *view*: There are two possibilities for the transformation of data. In the *surface* option, the points are processed for an orthogonal view on the profile. In the *projected* case, the data is transformed for a view on a vertical sectional pane (like a traditional drwaing on an excavation). Standart: *surface*

- *direction*: The position of the fgc in relation to the profile. The *original* option exports the data (nearly) parallel to the cutting line. *horizontal* will show the profile parallel to the x-axis (internal differences in height are still present). Standart: *horizontal*

```{r, echo=TRUE, fig.width=7, fig.height=7, warning= FALSE, message=FALSE}
devtools::load_all()
library(sp)
fotogram_sdf <- sp::SpatialPointsDataFrame(coords = fotogram_pts[ ,c(1,2,3)],
                                           data <- fotogram_pts,
                                           proj4string = sp::CRS('+proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs'))

#As an example only one profile
fotogram_sdf <- fotogram_sdf[fotogram_sdf@data$pr == 3,]


```

If plotted in QGIS the fgc points would look like the following.
The profile is tilt by 20° backwards. I.e. the points in south-east are below.


```{r, echo=TRUE, fig.width=7, fig.height=7}

plot(fotogram_sdf@data$x, fotogram_sdf@data$y, asp = 1)

```

###Step one: Preparing the data

To bring the data into the 2.5D space and to fold them forward, they must first be rotated. This step is also more practical when the data is to be exported for printing in the GIS.

At first we have to define the options. in this case we use the standart options for the profiles.

```{r, echo=TRUE, fig.width=7, fig.height=7}
fotogram_pts <- NULL
fotogram_pts <- fotogram_sdf

#The fuction for a sdf is called by 
#profile <- archprofile(
#   fotogram_pts = fotogram_sdf,
#   profile_col = "pr",
#   view_col = "view"
# )

#In this example everything will be done step by step
profile_col <- "pr"
view_col <- "view"
view <- "projected"
direction <- "horizontal"

```

Now we are checking if the data is a spatialdataframe (in this case it is important, that the sdf has a @coords[, 3] column, if not it is a 2D sdf and not to use) or a dataframe (containing x, y, z). The coordinates and the relevant data is stored in a dataframe.

```{r, echo=TRUE, fig.width=7, fig.height=7}

#If input is a spatialdataframe
  if(typeof(fotogram_pts)=="S4"){
    coord <- data.frame(
    x = fotogram_pts@coords[, 1],
    y = fotogram_pts@coords[, 2],
    z = fotogram_pts@coords[, 3],
    pr = fotogram_pts@data[, profile_col],
    view = fotogram_pts@data[, view_col]
  )
  }

# If input is a dataframe
  if(typeof(fotogram_pts) == "list" && !missing(z) ||
     typeof(fotogram_pts) == "list" && !missing(y) ||
     typeof(fotogram_pts) == "list" && !missing(x)){

      coord <- data.frame(
      x = fotogram_pts[,x],
      y = fotogram_pts[, y],
      z = fotogram_pts[, z],
      pr = fotogram_pts[, profile_col],
      view = fotogram_pts[, view_col]
    )
  } else if(typeof(fotogram_pts) == "list" && missing(z) ||
            typeof(fotogram_pts) == "list" && missing(y) ||
            typeof(fotogram_pts) == "list" && missing(x)) {
    stop('Coordinates missing')
  }

colnames(coord) <- c("x", "y", "z", "pr","view")

fotogram_pts@data

```

For performance reasons, some additional steps will be done:

```{r, echo=TRUE, fig.width=7, fig.height=7}
  #Now starting with each profile individual
  #possible nas has to be omitted
  coord <- na.omit(coord)
  #Getting all names of the profiles, to use the amoun for the n of iterations of the loop
  prnames <- levels(as.factor(coord$pr))
  
  #A dataframe with the same length as the import is used for the export,
  #A copy of the import df is used. All colums have 0 values for seeing errors

  coord_export <- coord
  coord_export$view <- NULL
  coord_export$pr <- 0
  coord_export$x <- 0
  coord_export$y <- 0
  coord_export$z <- 0
```

##Step two: roating on the z-axis

For each profile we start with rotating the profile parallel to the x-axis:
  
Therefore we use a dataframe containig only the data of one (the actual) profile.  
For roating the fgcs, the slope of the profile in relation th the x-axis is determined. For this step a linear regression is used.

```{r, echo=TRUE, fig.width=7, fig.height=7}
i<-1 #Countingvariable (in this case 1, normally the amount of profiles)


    #Writing all data of the actual profile in a teporary dataframe
    coord_proc <- coord[which(coord$pr == prnames[i]),]

    #A linear regression is used to get the gradient of the profile,
    #the regression balances the askew profile
    #First step is to rotate the profile control points around z-axis
    #therefore the angle of the profile to the x axis is necessary
    yw <- c(coord_proc$y) - min(coord_proc$y)
    xw <- c(coord_proc$x) - min(coord_proc$x)
    fm <- lm(yw ~ xw)

    #extrakte the solpe of the profile
    slope <- coef(fm)[2]

plot(xw, yw, asp=1)
abline(fm)
```

The slope of the straight and the point of view determines the angle of rotation. It will be distinguished between positive and negative slopes and the four main cardinal directions.The view is defined by the position of the observer (view from east)

There are four cases (+ special case m = 0):

1. m = - view = N/E -> clockwise
2. m = - view = S/W -> counterclockwise
3. m = + view = S/E -> clockwise
4. m = + view = N/W -> counterclockwise

Now we have to find the angle of rotation for this cases (rad -> deg)



```{r, echo=TRUE, fig.width=7, fig.height=7}
#Um die Fotogrammetrienägel korrekt anzeigen zu können, sollen diese gedreht werden.
#Dazu muss der Winkel zwischen der Regressionsgerade und der x-Achse berechnet werden
#Steigung der Gerade
slope <- coef(fm)[2]

if (slope < 0 && coord_proc$view[1] == "N" ||
    slope < 0 && coord_proc$view[1] == "E"){
  slope_deg <- 180 - abs((atan(slope) * 180) / pi) * -1
} else if (slope < 0 && coord_proc$view[1] == "S" ||
           slope < 0 && coord_proc$view[1] == "W"){
  slope_deg <- abs((atan(slope)*180)/pi)
} else if (slope > 0 && coord_proc$view[1] == "S" ||
           slope > 0 && coord_proc$view[1] == "E") {
  slope_deg <- ((atan(slope)*180)/pi)*-1
} else if (slope > 0 && coord_proc$view[1] == "N" ||
           slope > 0 && coord_proc$view[1] == "W") {
  slope_deg <- 180 - ((atan(slope)*180)/pi)
} else if (slope == 0 && coord_proc$view[1] == "N" ){
  slope_deg <- 180
} else if (slope == 0 && coord_proc$view[1] == "N" ){
  slope_deg <- 0
}

slope_deg
```


Nun muss der Drehpunkt bestimmt werden. Der liegt mittig aller Punkte
*Hier könnte ein Problem entstehen, möglicherweise ist es sinnvoller nur die Maximalwerte zu nehmen, allerdings liegen der Drehpunkt dann nicht auf der Steigungsgeraden, (die könnte man auch nur aus den äußeren berechnen, das muss man dann passend machen)*

  ```{r, echo=TRUE, fig.width=7, fig.height=7}
#Nun den Drehpunkt bestimmen.
#X-Wert ist die Mitte zwischen den x-Koordinaten
center_x <- sum(coord_proc$x)/length(coord_proc$x)
#Y-Wert
center_y <- sum(coord_proc$y)/length(coord_proc$y)
plot(xw, yw, asp=1)
abline(fm, col="red")
points(center_x,center_y,col="green")

```

Der nächste Schritt beinhaltet das Drehen (Im Beispiel: Ansicht von Nord).
Dafür wird wiederum ein df angelegt, in den die transformierten und rotierten Werte kommen.
*http://www.matheboard.de/archive/460078/thread.html*
  Hier besonders wichtig:

  *coord_proc$z[z]+center_y-mean(coord_proc$z)*

  Dadurch liegen die FG-Punkte später mittig über dem Profil

*Da es bei langen Profilen einen Fehler gibt, könnte der Nutzer diese in einer Spalte gruppieren, dann muss an dieser Stelle dafür gesorgt werden, dass die Segmente einzeln berechnet und danach nebeneinander dargestellt werden. Das würde die aktuelle Ungenauigkeit einfach lösen*

  ```{r, echo=TRUE, fig.width=7, fig.height=7}
coord_trans <- coord_proc
#Die Spalte view fällt raus
coord_trans$view <- NULL
#Für jeden Punkt des Profils mittels translation
#und rotation den neuen Punkt bestimmen
for (z in 1:nrow(coord_proc)){
  coord_trans[z,] <- c(
    center_x + (coord_proc$x[z] - center_x) *
      cos(slope_deg / 180 * pi) - sin(slope_deg / 180 * pi) *
      (coord_proc$y[z] - center_y),
    center_y + (coord_proc$x[z] - center_x) *
      sin(slope_deg / 180 * pi) + (coord_proc$y[z] - center_y) *
      cos(slope_deg / 180 * pi),
    (coord_proc$z[z]+center_y-mean(coord_proc$z)),
    coord_proc$pr[z])
}

plot(coord$x,coord$y,asp=1)
points(coord_trans$x,coord_trans$y, col="red")
```

Jetzt könnten schon die z und y Werte getauscht werden und man hat die Frontalansicht auf das Profil, das ist jedoch nur korrekt, wenn das Profil exakt senkrecht steht. Ob es das tut, lässt bei der Seitenansicht prüfen:

  ```{r, echo=TRUE, fig.width=7, fig.height=7}
plot(coord_trans$y,coord_trans$z,asp=1)
```

Es ist also gekippt. Die Entzerrung geht so nicht, da der Blickwinkel immer orthogonal zu der Z-Achse sein muss, damit keine Verzerrung entsteht
.
Also müssen die oben durchgeführten Schritte für die Rotation um die z-Achse wiederholt werden.

Hier gab es das Problem, dass nicht mit den echten Koordinatenwerten die lm durchgeführt werden konnte, da gibt es scheinbar ein Problem mit den langen Zahlen. Also wir der Wert an 0 angepasst und die Steigung dann übernommen (*
                                                                                                                                                                                                                                     z_yw <- c(coord_trans$y -  min(c(coord_trans$y,coord_trans$z)))
                                                                                                                                                                                                                                   z_zw <- c(coord_trans$z -  min(c(coord_trans$y,coord_trans$z)))* ).

```{r, echo=TRUE, fig.width=7, fig.height=7}
#Jetzt das ganze für die z-Achse, um eine Kippung des Profils zu minimieren

z_yw <- c(coord_trans$y -  min(c(coord_trans$y,coord_trans$z)))
z_zw <- c(coord_trans$z -  min(c(coord_trans$y,coord_trans$z)))

z_fm <- lm(z_zw ~ z_yw)

plot(z_yw, z_zw)
abline(z_fm, col="red")

```

Hier ist die Bestimmung des Roationswinkels einfacher, da immer nur aufgerichtet wird. Also braucht es nur den Fall poisitive oder negative Steigung.
Dann die Bestimmung des Drehpunktes

```{r, echo=TRUE, fig.width=7, fig.height=7}
#Steigungswinkel berechnen
z_slope <- coef(z_fm)[2]

if (z_slope < 0){

  z_slope_deg <- (90 - abs((atan(z_slope)*180)/pi))*-1
} else if (z_slope > 0){
  z_slope_deg <- 90 - ((atan(z_slope)*180)/pi)
} else if (z_slope == 0){
  z_slope_deg <- 0
}

z_slope_deg

z_center_y <- sum(coord_trans$y)/length(coord_trans$y)
z_center_z <- sum(coord_trans$z)/length(coord_trans$z)

plot(coord_trans$y, coord_trans$z, asp=1)
points(z_center_y,z_center_z,col="green")
```


Und wieder drehen, diesmal um die X-Achse

```{r, echo=TRUE, fig.width=7, fig.height=7}

z_coord <- coord_trans

for (z in 1:nrow(z_coord)){
  z_coord[z,] <- c(
    coord_trans$x[z],
    z_center_y + (coord_trans$y[z] - z_center_y) * cos(z_slope_deg / 180 * pi) -
      (coord_trans$z[z] - z_center_z) * sin(z_slope_deg / 180 * pi),
    z_center_z + (coord_trans$y[z] - z_center_y) * sin(z_slope_deg / 180 * pi) +
      (coord_trans$z[z] - z_center_z) * cos(z_slope_deg / 180 * pi),

    coord_trans$pr[z])
  #http://www.matheboard.de/archive/460078/thread.html

}

plot(coord_trans$y, coord_trans$z, asp=1)
points(z_center_y,z_center_z,col="green")
points(z_coord$y,z_coord$z, col="red")

coord_trans <- z_coord
coord_export[which (coord$pr==prnames[i]), ] <- coord_trans


```


Wenn dies für alle Profile durchgeführt worden ist, folgt die Umwandlung in einen sdf, wobei x und y vertauscht sind, sodass ich die Ansicht auf das Profil bekomme:


  ```{r, echo=TRUE, fig.width=7, fig.height=7}

#Das ganze zu einem Spatialdataframe machen
export <- SpatialPointsDataFrame(coords=coord_export[,c(1,3)],
                                 data = coord_export,
                                 proj4string = (fotogram_pts@proj4string))
plot(coord_export$x,coord_export$z, col="red")
points(coord_export$x,coord_export$y, asp=1)

```

##Weitere Ziele

- Import auch via table (für GIS)

- Prüfen warum bei langen Profilen nicht genau
-> Das größte Problem sind die Unterschiede in der Y-Achse. Sind die Werte hier unterschiedlich (nach der Rotation parallel zur X-Achse), funktionier das Klappen nicht richtig.
-> Lösung wäre das getrennte umrechnen der Punkte verschiedener Ebenen bzw. das der Einzelsegmente eines langen Profils (am besten mit Gruppierung, dann muss sich der Nutzer um nichts kümmern)

- Welchen Einfluss haben unregelmäßig verteilte Punkte innerhalb des Profiles?
-> Sollten nur die Eckpunkte zur Berechnung von Rotationsachse genutzt werden (Reaktion des lm)?
-> Nach Tests ist der Einfluss zu vernachlässigen

- Berechnung des Fehlers
-> Abstand zweier Punkte im Orginalzusand und in der Aufsicht?