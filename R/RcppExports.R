# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Fills hexahedrons with a systematic point raster
#'
#' See \url{https://stackoverflow.com/questions/36115215/filling-a-3d-body-with-a-systematic-point-raster}
#' for a description of the function and how it was developed.
#'
#' @param hex dataframe with three columns and eight rows to define a hexahedron by its corner
#' point coordinates
#' @param res numeric value > 0 and <= 1 for the resolution of the point raster
#'
#' @return data.frame with the spatial coordinates of the resulting points of the filling raster
#'
#' @examples
#' hexatestdf <- data.frame(
#'   x = c(0,1,0,4,5,5,5,5),
#'   y = c(1,1,4,4,1,1,4,4),
#'   z = c(4,8,4,9,4,8,4,6)
#' )
#'
#' cx = fillhexa(hexatestdf, 0.1)
#'
#' #library(rgl)
#' #plot3d(
#' # cx[,1], cx[,2], cx[,3],
#' # type = "p",
#' # xlab = "x", ylab = "y", zlab = "z"
#' #)
#'
#' @export
fillhexa <- function(hex, res) {
    .Call('recexcavAAR_fillhexa', PACKAGE = 'recexcavAAR', hex, res)
}

#' test
#'
#' @description
#' Based on this solution:
#' Copyright (c) 1970-2003, Wm. Randolph Franklin
#' \url{https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html}
#'
#' @details
#' For discussion see: \url{http://stackoverflow.com/questions/217578/how-can-i-determine-whether-a-2d-point-is-within-a-polygon/2922778#2922778}
#'
#' @param vertx test
#' @param verty test
#' @param testx test
#' @param testy test
#'
#' @return test
#'
#' @examples
#' df <- data.frame(
#'   x = c(1,1,2,2),
#'   y = c(1,2,1,2)
#' )
#'
#' pnp(df$x, df$y, 1.5, 1.5)
#' pnp(df$x, df$y, 2.5, 2.5)
#'
#' # caution: false-negatives in edge-cases:
#' pnp(df$x, df$y, 2, 1.5)
#'
#' @export
pnp <- function(vertx, verty, testx, testy) {
    .Call('recexcavAAR_pnp', PACKAGE = 'recexcavAAR', vertx, verty, testx, testy)
}

#' test
#'
#' @description
#' test
#'
#' @param vertx test
#' @param verty test
#' @param testx test
#' @param testy test
#'
#' @return test
#'
#' @examples
#' polydf <- data.frame(
#'   x = c(1,1,2,2),
#'   y = c(1,2,1,2)
#' )
#'
#' testdf <- data.frame(
#'   x = c(1.5, 2.5),
#'   y = c(1.5, 2.5)
#' )
#'
#' pnpmulti(polydf$x, polydf$y, testdf$x, testdf$y)
#'
#' @export
pnpmulti <- function(vertx, verty, testx, testy) {
    .Call('recexcavAAR_pnpmulti', PACKAGE = 'recexcavAAR', vertx, verty, testx, testy)
}

#' position decision in relation to a set of stacked surfaces
#'
#' \code{posdec} has the purpose to make a decision about the position of individual points in relation
#' to a set of stacked surfaces. The decision is made by comparing the mean z-axis value of the four
#' horizontally closest points of a surface to the z-axis value of the point in question.
#'
#' @param crlist data.frame with the spatial coordinates of the points of interest
#' @param maplist list of data.frames which contain the points that make up the surfaces
#'
#' @return data.frame with the spatial coordinates of the points of interest and the respective position
#' information
#'
#' @examples
#' df1 <- data.frame(
#'   x = rnorm(50),
#'   y = rnorm(50),
#'   z = rnorm(50) - 5
#' )
#'
#' df2 <- data.frame(
#'   x = rnorm(50),
#'   y = rnorm(50),
#'   z = rnorm(50) + 5
#')
#'
#' lpoints <- list(df1, df2)
#'
#' maps <- kriglist(lpoints, lags = 3, model = "spherical")
#'
#' finds <- data.frame(
#'   x = c(0, 1, 0.5, 0.7),
#'   y = c(0.5, 0, 1, 0.7),
#'   z = c(-10, 10, 0, 2)
#' )
#'
#' posdec(finds, maps)
#'
#' @export
posdec <- function(crlist, maplist) {
    .Call('recexcavAAR_posdec', PACKAGE = 'recexcavAAR', crlist, maplist)
}

#' position decision in relation to a set of stacked surfaces (for lists of data.frames)
#'
#' \code{posdeclist} works as \code{posdec} but not just for a single data.frame but for a list of
#' data.frames
#'
#' @param crlist list of data.frames with the spatial coordinates of the points of interest
#' @param maplist list of data.frames which contain the points that make up the surfaces
#'
#' @return list of data.frames with the spatial coordinates of the points of interest and the respective
#' position information
#'
#' @examples
#' df1 <- data.frame(
#'   x = rnorm(50),
#'   y = rnorm(50),
#'   z = rnorm(50) - 5
#' )
#'
#' df2 <- data.frame(
#'   x = rnorm(50),
#'   y = rnorm(50),
#'   z = rnorm(50) + 5
#')
#'
#' lpoints <- list(df1, df2)
#'
#' maps <- kriglist(lpoints, lags = 3, model = "spherical")
#'
#' hexadf1 <- data.frame(
#'   x = c(0, 1, 0, 4, 5, 5, 5, 5),
#'   y = c(1, 1, 4, 4, 1, 1, 4, 4),
#'   z = c(1, 5, 1, 6, 1, 5, 1, 3)
#' )
#'
#' hexadf2 <- data.frame(
#'   x = c(0, 1, 0, 4, 5, 5, 5, 5),
#'   y = c(1, 1, 4, 4, 1, 1, 4, 4),
#'   z = c(-1, -5, -1, -6, -1, -5, -1, -3)
#' )
#'
#' cx1 <- fillhexa(hexadf1, 0.1)
#' cx2 <- fillhexa(hexadf2, 0.1)
#'
#' cubelist <- list(cx1, cx2)
#'
#' posdeclist(cubelist, maps)
#'
#' @export
posdeclist <- function(crlist, maplist) {
    .Call('recexcavAAR_posdeclist', PACKAGE = 'recexcavAAR', crlist, maplist)
}

#' Transformation of numeric matrices wide to long format
#'
#' Transforms a set of two independent variables in vectors and a dependent variable in a wide
#' matrix to a long matrix that combines the information. The result is exported as a data.frame
#'
#' @param x vector of first independent variable. e.g. vector with x-axis spatial points
#' @param y vector of second independent variable. e.g. vector with y-axis spatial points
#' @param z matrix of dependent variable. e.g. matrix with z-axis spatial points
#'
#' @return data.frame with three columns x, y and z
#'
#' @examples
#' x <- c(1, 1, 1, 2, 2, 2, 3, 3, 4)
#' y <- c(1, 2, 3, 1, 2, 3, 1, 2, 3)
#' z <- c(3, 4, 2, 3, NA, 5, 6, 3, 1)
#'
#' sw <- spatialwide2(x, y, z, digits = 3)
#'
#' spatiallong2(sw$x, sw$y, sw$z)
#'
#' @export
spatiallong2 <- function(x, y, z) {
    .Call('recexcavAAR_spatiallong2', PACKAGE = 'recexcavAAR', x, y, z)
}

#' Transformation of numeric matrices from long to wide format
#'
#' Transforms a set of two independent and one dependent variables in vectors from a long
#' to a wide format and exports this result as a list
#'
#' @param x vector of first independent variable. e.g. vector with x-axis spatial points
#' @param y vector of second independent variable. e.g. vector with y-axis spatial points
#' @param z vector of dependent variable. e.g. vector with z-axis spatial points
#' @param digits integer indicating the number of decimal places to be used for rounding
#' the dependent variables \code{x} and \code{y}.
#'
#' @return List with three elements:
#'
#' $x: vector with ascendingly sorted, unique values of the first independent variable \code{x}
#'
#' $y: vector with ascendingly sorted, unique values of the second independent variable \code{y}
#'
#' $z: matrix with the values of z for the defined combinations of \code{x} (columns) and
#' \code{y} (rows)
#'
#' @examples
#' x <- c(1, 1, 1, 2, 2, 2, 3, 3, 4)
#' y <- c(1, 2, 3, 1, 2, 3, 1, 2, 3)
#' z <- c(3, 4, 2, 3, NA, 5, 6, 3, 1)
#'
#' spatialwide2(x, y, z, digits = 3)
#'
#' @export
spatialwide2 <- function(x, y, z, digits) {
    .Call('recexcavAAR_spatialwide2', PACKAGE = 'recexcavAAR', x, y, z, digits)
}

#' center determination for hexahedrons
#'
#' \code{spitcenter} determines a center point for an input hexahedron
#'
#' @param hex dataframe with three columns and eight rows to define a hexahedron by its corner
#' point coordinates
#'
#' @return numeric vector with the spatial coordinates of the center point of the input hexahedron
#'
#' @examples
#' hexatestdf <- data.frame(
#'   x = c(0,1,0,4,5,5,5,5),
#'   y = c(1,1,4,4,1,1,4,4),
#'   z = c(4,8,4,9,4,8,4,6)
#' )
#'
#' center <- spitcenter(hexatestdf)
#'
#' #library(rgl)
#' #plot3d(
#' # hexatestdf$x, hexatestdf$y, hexatestdf$z,
#' # type = "p",
#' # xlab = "x", ylab = "y", zlab = "z"
#' #)
#' #plot3d(
#' #  center[1], center[2], center[3],
#' #  type = "p",
#' #  col = "red",
#' #  add = TRUE
#' #)
#'
#' @export
spitcenter <- function(hex) {
    .Call('recexcavAAR_spitcenter', PACKAGE = 'recexcavAAR', hex)
}

#' spitcenternat
#'
#' \code{spitcenternat} determines center points of spits if the excavation followed natural layers.
#' In this case spits are not perfectly defined hexahedrons. Just the horizontal outlines are clear -
#' the vertical edges vary a lot. To solve this, \code{spitcenternat} calculates the horizontal center
#' of a spit and determines its vertical position in relation to the natural/semiartificial surfaces
#' that define its top and bottom. This is done for all defined layers.
#'
#' @param hex data.frame with the horizontal outlines of the spit defined by four points
#' @param maplist list of data.frames which contain the points that make up the surfaces
#'
#' @return data.frame with the spatial coordinates of the center points
#'
#' @examples
#' df1 <- data.frame(
#'   x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
#'   y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
#'   z = c(0.9+0.05*rnorm(6), 0.9+0.05*rnorm(14), 1.3+0.05*rnorm(14), 1.2+0.05*rnorm(6))
#' )
#'
#' df2 <- data.frame(
#'     x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
#'     y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
#'     z = c(0.6+0.05*rnorm(6), 0.6+0.05*rnorm(14), 1.0+0.05*rnorm(14), 0.9+0.05*rnorm(6))
#' )
#'
#' df3 <- data.frame(
#'     x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
#'     y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
#'     z = c(0.3+0.05*rnorm(6), 0.3+0.05*rnorm(14), 0.7+0.05*rnorm(14), 0.6+0.05*rnorm(6))
#' )
#'
#' lpoints <- list(df1, df2, df3)
#'
#' maps <- kriglist(lpoints, lags = 3, model = "spherical")
#'
#' hexatestdf <- data.frame(
#'     x = c(1, 1, 1, 1, 2, 2, 2, 2),
#'     y = c(0, 1, 0, 1, 0, 1, 0, 1)
#' )
#'
#' spitcenternat(hexatestdf, maps)
#'
#' @export
spitcenternat <- function(hex, maplist) {
    .Call('recexcavAAR_spitcenternat', PACKAGE = 'recexcavAAR', hex, maplist)
}

#' spitcenternatlist
#'
#' \code{spitcenternatlist} works as \code{spitcenternat} but not just for a single data.frame but for a list of
#' data.frames
#'
#' @param hexlist list of data.frames with the horizontal outlines of the spit defined by four points
#' @param maplist list of data.frames which contain the points that make up the surfaces
#'
#' @return list of data.frames with the spatial coordinates of the center points
#'
#' @examples
#' df1 <- data.frame(
#' x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
#'   y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
#'   z = c(0.9+0.05*rnorm(6), 0.9+0.05*rnorm(14), 1.3+0.05*rnorm(14), 1.2+0.05*rnorm(6))
#' )
#'
#' df2 <- data.frame(
#'     x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
#'     y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
#'     z = c(0.6+0.05*rnorm(6), 0.6+0.05*rnorm(14), 1.0+0.05*rnorm(14), 0.9+0.05*rnorm(6))
#' )
#'
#' df3 <- data.frame(
#'     x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
#'     y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
#'     z = c(0.3+0.05*rnorm(6), 0.3+0.05*rnorm(14), 0.7+0.05*rnorm(14), 0.6+0.05*rnorm(6))
#' )
#'
#' lpoints <- list(df1, df2, df3)
#'
#' maps <- kriglist(lpoints, lags = 3, model = "spherical")
#'
#' hexatestdf1 <- data.frame(
#'   x = c(1, 1, 1, 1, 2, 2, 2, 2),
#'   y = c(0, 1, 0, 1, 0, 1, 0, 1)
#' )
#'
#' hexatestdf2 <- data.frame(
#'   x = c(0, 0, 0, 0, 1, 1, 1, 1),
#'   y = c(0, 1, 0, 1, 0, 1, 0, 1)
#' )
#'
#' hexs <- list(hexatestdf1, hexatestdf2)
#'
#' spitcenternatlist(hexs, maps)
#'
#' @export
spitcenternatlist <- function(hexlist, maplist) {
    .Call('recexcavAAR_spitcenternatlist', PACKAGE = 'recexcavAAR', hexlist, maplist)
}

